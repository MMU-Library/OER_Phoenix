[file name]: OER_Django_Demo-combined_files.txt
[file content begin]

## Project: Open Educational Resourcer - AI-Powered Educational Resource Platform

**PROJECT SUMMARY:**
A Django-based platform supporting AI-powered semantic search, multi-source OER ingestion (OER Commons, OpenStax), vector search with pgvector, and Talis reading list export. Containerized with Docker and asynchronous tasks handled via Celery + Redis.

**CORE ARCHITECTURE:**
- Backend: Django 5.2.1
- Database: PostgreSQL 14 with pgvector extension (384-dimensional vector embeddings)
- AI/ML: HuggingFace Transformers, SentenceTransformers (model: all-MiniLM-L6-v2)
- Vector Search: pgvector with cosine similarity
- Task Queue: Celery + Redis
- Containerization: Docker Compose
- Frontend: Django templates + Bootstrap

**KEY DEPENDENCIES (requirements.txt):**
- django==5.2.1
- djangorestframework
- langchain + langchain-community + langchain-huggingface
- chromadb
- sentence-transformers==3.0.0
- transformers, torch
- celery[redis], redis
- pgvector, psycopg2-binary, numpy, pandas, tqdm

---

## FILE STRUCTURE AND CONTENTS

### Docker Configuration Files

---
docker-compose.yml
---
# OER Recommender Prototype Docker Compose File
services:
  web:
    build: .
    command: >
      sh -c "while ! nc -z db 5432; do sleep 1; echo 'Waiting for database...'; done;
            python manage.py makemigrations resources;
            python manage.py migrate;
            python manage.py runserver 0.0.0.0:8000"
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    env_file:
      - .env

  db:
    image: pgvector/pgvector:pg14
    volumes:
      - postgres_data:/var/lib/postgresql/data/
      - ./docker-entrypoint-initdb.d:/docker-entrypoint-initdb.d
    environment:
      POSTGRES_DB: oer_rebirth
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_INITDB_ARGS: "--data-checksums"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 10

  redis:
    image: redis:7-alpine

  celery: 
    build: .
    command: celery -A oer_prototype worker -l info
    depends_on:
      - db
      - redis
    volumes:
      - .:/app
    env_file:
      - .env

  celery-beat:
    build: .
    command: celery -A oer_prototype beat --loglevel=info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    env_file:
      - .env

volumes:
  postgres_data:

---
Dockerfile
---
# Open_Educational_Resourcer/Dockerfile
FROM python:3.11-slim-bookworm

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    libpq-dev \
    postgresql-client \
    netcat-openbsd \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project files
COPY . .

---
docker-entrypoint.sh
---
#!/bin/sh

# Simple database check
if [ -n "$DB_HOST" ]; then
    echo "Waiting for database at $DB_HOST:$DB_PORT..."
    while ! nc -z $DB_HOST $DB_PORT; do sleep 0.5; done
    echo "Database ready!"
fi

# Create superuser non-interactively
echo "Creating superuser..."
python manage.py shell -c "
from django.contrib.auth import get_user_model;
User = get_user_model();
if not User.objects.filter(username='admin').exists():
    User.objects.create_superuser('admin', 'admin@example.com', 'adminpass')
    print('Superuser created')
else:
    print('Superuser already exists')
"

exec "$@"

---
docker-entrypoint-initdb.d/init-vector.sql
---
CREATE EXTENSION IF NOT EXISTS vector;

### Django Project Files

---
oer_prototype/settings.py
---
"""
Django settings for oer_prototype project.
Generated by 'django-admin startproject' using Django 5.2.1.
"""
import environ
import os
from pathlib import Path
import sys
from django.db import OperationalError, connection
import warnings
from django.db.backends.utils import CursorWrapper
warnings.filterwarnings("ignore", category=RuntimeWarning, module="django.db.backends.utils")

# Initialize environment variables early
env = environ.Env()
environ.Env.read_env()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('DJANGO_SECRET_KEY', default='insecure-dev-key')

# Security settings - DEVELOPMENT CONFIG
SECURE_SSL_REDIRECT = False  # Disable for development
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False
SECURE_HSTS_SECONDS = 0  # Disable HSTS for development

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'resources',
]

# Authentication backends
AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'oer_prototype.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'oer_prototype.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': env('DB_NAME'),
        'USER': env('DB_USER'),
        'PASSWORD': env('DB_PASSWORD'),
        'HOST': env('DB_HOST', default='localhost'),
        'PORT': env('DB_PORT', default='5432'),
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files
STATIC_URL = '/static/'
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Celery Configuration
CELERY_BROKER_URL = 'redis://redis:6379/0'
CELERY_RESULT_BACKEND = 'redis://redis:6379/0'

from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    'fetch-oer-every-day': {
        'task': 'resources.tasks.fetch_oer_resources_task',
        'schedule': crontab(hour=0, minute=0),
    },
}

# Environment-based configuration
if os.environ.get('DJANGO_DEBUG', 'True') == 'True':
    DEBUG = True
    # Development security settings
    SECURE_SSL_REDIRECT = False
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
    SECURE_HSTS_SECONDS = 0
else:
    DEBUG = False
    # Production security settings
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_HSTS_SECONDS = 31536000  # 1 year

# Dynamic ALLOWED_HOSTS
ALLOWED_HOSTS = os.environ.get('DJANGO_ALLOWED_HOSTS', 'localhost,127.0.0.1,0.0.0.0').split(',')

---
oer_prototype/urls.py
---
"""
URL configuration for oer_prototype project.
"""
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('resources.urls')),
]

---
oer_prototype/celery.py
---
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'oer_prototype.settings')

app = Celery('oer_prototype')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

### Resources App Files

---
resources/models.py
---
from django.db import models
from pgvector.django import VectorField

class OERResource(models.Model):
    embedding = VectorField(dimensions=384, null=True, blank=True)  # 384 for MiniLM-L6-v2
    title = models.CharField(max_length=200)
    publisher = models.CharField(max_length=200, blank=True)
    source = models.CharField(max_length=100)
    description = models.TextField()
    license = models.CharField(max_length=500)
    url = models.URLField()
    accessibility = models.BooleanField(default=True)
    csv_file = models.FileField(upload_to='csv_uploads/', null=True, blank=True)
    
    class Meta:
        verbose_name = "OER Resource"
        verbose_name_plural = "OER Resources"
        managed = True
        db_table = 'resources_oerresource'
    
    def __str__(self):
        return self.title

---
resources/admin.py
---
from django.contrib import admin
from django.urls import path
from django.shortcuts import render, redirect
from .models import OERResource
import csv
import io
from .forms import BulkCSVUploadForm

class OERResourceAdmin(admin.ModelAdmin):
    change_list_template = "admin/resources/oerresource_changelist.html"

    def get_urls(self):
        urls = super().get_urls()
        custom_urls = [
            path('upload-csv/', self.admin_site.admin_view(self.upload_csv), name='oerresource_upload_csv'),
        ]
        return custom_urls + urls

    def upload_csv(self, request):
        if request.method == "POST":
            form = BulkCSVUploadForm(request.POST, request.FILES)
            if form.is_valid():
                csv_file = request.FILES['csv_file']
                reader = csv.DictReader(io.TextIOWrapper(csv_file, encoding='utf-8', errors='replace'))
                # Clean up fieldnames (strip spaces, BOM, and ignore empty)
                reader.fieldnames = [fn.strip().replace('\ufeff', '') for fn in reader.fieldnames if fn and fn.strip()]
                print("CSV HEADERS (admin):", reader.fieldnames)  # For debugging

                required_columns = ['title', 'source', 'description', 'license', 'url']
                if not all(col in reader.fieldnames for col in required_columns):
                    self.message_user(request, f"CSV is missing required columns: {required_columns}", level='error')
                    return redirect("..")

                for row in reader:
                    OERResource.objects.create(
                        title=row.get('title', ''),
                        source=row.get('source', ''),
                        description=row.get('description', ''),
                        license=row.get('license', ''),
                        url=row.get('url', ''),
                        publisher=row.get('publisher', ''),
                    )
                self.message_user(request, "CSV uploaded successfully!")
                return redirect("..")
        else:
            form = BulkCSVUploadForm()
        return render(request, "admin/resources/csv_upload.html", {"form": form})

admin.site.register(OERResource, OERResourceAdmin)

---
resources/views.py
---
from django.shortcuts import render, redirect
from .models import OERResource
from .forms import BulkCSVUploadForm
import csv
from django.contrib import messages
from django.http import HttpResponse
from .ai_utils import OERRetriever
from pgvector.django import L2Distance
from .services.ai_utils import get_embedding_model
import numpy as np
from .tasks import export_to_talis
from .forms import ExportForm
import io
from django.urls import reverse

# AI search view
from .ai_utils import OERRetriever

def ai_search(request):
    if request.method == 'POST':
        query = request.POST.get('query', '').strip()
        if not query:
            return render(request, 'resources/search.html', {
                'results': [],
                'query': query,
                'ai_search': True
            })
        retriever = OERRetriever()
        results = retriever.get_similar_resources(query)
        
        # Invert and normalize scores so higher is better
        if results:
            scores = [score for _, score in results]
            max_score = max(scores)
            min_score = min(scores)
        else:
            max_score = min_score = 0

        resource_scores = []
        for doc, score in results:
            resource_id = doc.metadata['id']
            try:
                resource = OERResource.objects.get(id=resource_id)
                # Normalize: similarity = 1 - (score - min) / (max - min)
                if max_score != min_score:
                    similarity = 1 - ((score - min_score) / (max_score - min_score))
                else:
                    similarity = 1  # If all scores are the same
                similarity_percent = round(similarity * 100)
                resource_scores.append((resource, similarity_percent))
            except OERResource.DoesNotExist:
                continue

        return render(request, 'resources/search.html', {
            'results': resource_scores,
            'query': query,
            'ai_search': True
        })
    # For GET requests, just show the search page with no results
    return render(request, 'resources/search.html', {
        'results': [],
        'query': '',
        'ai_search': True
    })

# Export to Talis view
from .tasks import export_to_talis

def export_resources(request):
    if request.method == 'POST':
        form = ExportForm(request.POST)
        if form.is_valid():
            resource_ids = form.cleaned_data['resource_ids']
            title = form.cleaned_data['title']
            description = form.cleaned_data['description']
            
            # Start async export task
            export_to_talis.delay(resource_ids, title, description)
            
            return redirect('export_success')
    else:
        form = ExportForm()
    
    return render(request, 'resources/export.html', {'form': form})

def export_success(request):
    return render(request, 'resources/export_success.html')
    
# csv upload views
def csv_upload(request):
    if request.method == 'POST':
        form = BulkCSVUploadForm(request.POST, request.FILES)
        if form.is_valid():
            csv_file = request.FILES['csv_file']
            reader = csv.DictReader(io.TextIOWrapper(csv_file, encoding='utf-8', errors='replace'))
            reader.fieldnames = [fn.strip().replace('\ufeff', '') for fn in reader.fieldnames if fn and fn.strip()]
            required_columns = [
                'Date Added', 'Title', 'Type', 'Item Link', 'Local Control Number',
                'ISBN10', 'ISBN13', 'ISSN', 'EISSN', 'DOI', 'Importance',
                'Note for Student', 'Part of'
            ]
            if not all(col in reader.fieldnames for col in required_columns):
                messages.error(request, "CSV is missing required columns")
                return redirect('resources:csv_upload')

            created = []
            skipped = []
            for row in reader:
                title = row.get('Title', '').strip()
                url = row.get('Item Link', '').strip()
                # You can map other fields as needed
                if not title or not url:
                    skipped.append(row)
                    continue
                if OERResource.objects.filter(title=title, url=url).exists():
                    skipped.append(row)
                    continue
                resource = OERResource.objects.create(
                    title=title,
                    source=row.get('Type', ''),
                    description=row.get('Note for Student', ''),
                    license=row.get('DOI', ''),
                    url=url,
                )
                created.append(resource)

            messages.success(request, f"CSV uploaded! {len(created)} resources created, {len(skipped)} skipped.")
            request.session['uploaded_resource_ids'] = [r.id for r in created]
            return redirect('resources:batch_ai_search')
    else:
        form = BulkCSVUploadForm()

    return render(request, "resources/taliscsv_upload.html", {"form": form})

def csv_download(request):
    # Create CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="oer_resources.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['title', 'source', 'description', 'license', 'url', 'match_score', 'accessibility'])
    
    resources = OERResource.objects.all()
    for resource in resources:
        writer.writerow([
            resource.title,
            resource.source,
            resource.description,
            resource.license,
            resource.url,
            resource.match_score,
            resource.accessibility
        ])
    
    return response

# Talis CSV template view
from django.http import HttpResponse

def talis_csv_template(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="talis_template.csv"'
    writer = csv.writer(response)
    writer.writerow([
        'Date Added', 'Title', 'Type', 'Item Link', 'Local Control Number',
        'ISBN10', 'ISBN13', 'ISSN', 'EISSN', 'DOI', 'Importance',
        'Note for Student', 'Part of'
    ])
    return response

# OG views
def batch_ai_search(request):
    ids = request.session.get('uploaded_resource_ids', [])
    uploaded_resources = OERResource.objects.filter(id__in=ids)
    grouped_results = []
    retriever = OERRetriever()
    for resource in uploaded_resources:
        matches = retriever.get_similar_resources(resource.title)[:3]
        grouped_results.append({
            "resource": resource,
            "matches": matches,
        })
    return render(request, "resources/search.html", {
        "grouped_results": grouped_results,
        "batch_search": True,
    })

def compare_view(request):
    resource_ids = request.GET.getlist('resource_ids')
    resources = OERResource.objects.filter(id__in=resource_ids)
    return render(request, 'resources/compare.html', {'resources': resources})

def talis_preview(request):
    resource_id = request.GET.get('resource_id')
    resource = OERResource.objects.get(id=resource_id)
    return render(request, 'resources/talis_preview.html', {'resource': resource})

def export_to_talis(request):
    if request.method == 'POST':
        resource_id = request.POST.get('resource_id')
        resource = OERResource.objects.get(id=resource_id)
        # TODO: Add logic to push to Talis
        messages.success(request, f"Resource '{resource.title}' pushed to Talis!")
        # Redirect with resource_id in query string
        return redirect(f"{reverse('resources:talis_preview')}?resource_id={resource_id}")
    else:
        return redirect('resources:ai_search')

---
resources/urls.py
---
from django.urls import path
from django.shortcuts import redirect
from . import views

app_name = 'resources'

urlpatterns = [
    path('', lambda request: redirect('resources:ai_search'), name='home'),
    path('compare/', views.compare_view, name='compare'),
    path('talis-preview/', views.talis_preview, name='talis_preview'),
    path('batch-upload/', views.csv_upload, name='csv_upload'),
    path('download-csv/', views.csv_download, name='csv_download'),
    path('ai-search/', views.ai_search, name='ai_search'),
    path('export-to-talis/', views.export_to_talis, name='export_to_talis'),
    path('talis-csv-template/', views.talis_csv_template, name='talis_csv_template'),
]

### AI Processing Services

---
resources/services/ai_utils.py
---
from sentence_transformers import SentenceTransformer
from django.db.models import F
from pgvector.django import L2Distance
from resources.models import OERResource
import numpy as np

model = None

def get_embedding_model():
    global model
    if model is None:
        model = SentenceTransformer('all-MiniLM-L6-v2')
    return model

def generate_embeddings(batch_size=50):
    model = get_embedding_model()
    resources = OERResource.objects.filter(embedding__isnull=True)
    
    for i in range(0, resources.count(), batch_size):
        batch = resources[i:i+batch_size]
        texts = [f"{r.title} {r.description}" for r in batch]
        embeddings = model.encode(texts, show_progress_bar=True)
        
        for resource, embedding in zip(batch, embeddings):
            resource.embedding = embedding.tolist()
            resource.save()

---
resources/services/oer_api.py
---
import requests
from django.db import transaction
from resources.models import OERResource  
from .ai_utils import generate_embeddings

OER_SOURCES = [
    {
        'name': 'OER Commons',
        'url': 'https://www.oercommons.org/api/resources',
        'params': {'format': 'json', 'per_page': 50},
        'field_map': {
            'title': 'title',
            'description': 'description',
            'url': 'url',
            'license': 'license'
        }
    },
    {
        'name': 'OpenStax',
        'url': 'https://api.openstax.org/api/v2/resources',
        'params': {'page[size]': 50},
        'field_map': {
            'title': 'attributes.title',
            'description': 'attributes.description',
            'url': 'attributes.url',
            'license': 'attributes.license'
        }
    }
]

def fetch_nested_value(data, key_path):
    keys = key_path.split('.')
    for key in keys:
        data = data.get(key, {})
    return data if isinstance(data, str) else ''

@transaction.atomic
def fetch_oer_resources():
    for source in OER_SOURCES:
        try:
            response = requests.get(source['url'], params=source.get('params', {}))
            response.raise_for_status()
            data = response.json()
            
            # Handle different response structures
            items = data.get('results', []) if 'results' in data else data.get('data', [])
            
            for item in items:
                resource_data = {
                    'title': fetch_nested_value(item, source['field_map']['title']),
                    'description': fetch_nested_value(item, source['field_map']['description']),
                    'url': fetch_nested_value(item, source['field_map']['url']),
                    'license': fetch_nested_value(item, source['field_map'].get('license', '')),
                    'source': source['name']
                }
                
                # Create or update resource
                resource, created = OERResource.objects.update_or_create(
                    url=resource_data['url'],
                    defaults=resource_data
                )
                
            print(f"Fetched {len(items)} resources from {source['name']}")
        except Exception as e:
            print(f"Error fetching from {source['name']}: {str(e)}")
    
    # Generate embeddings after import
    generate_embeddings()

---
resources/services/talis.py
---
import requests
import os
from django.conf import settings
from resources.models import OERResource

TALIS_API_URL = "https://rl.talis.com/3/"

class TalisClient:
    def __init__(self):
        self.tenant = os.getenv('TALIS_TENANT')
        self.client_id = os.getenv('TALIS_CLIENT_ID')
        self.client_secret = os.getenv('TALIS_CLIENT_SECRET')
        self.access_token = None
    
    def authenticate(self):
        url = "https://users.talis.com/oauth/tokens"
        payload = {
            'grant_type': 'client_credentials',
            'client_id': self.client_id,
            'client_secret': self.client_secret,
            'scope': 'https://rl.talis.com/3/'
        }
        response = requests.post(url, data=payload)
        response.raise_for_status()
        self.access_token = response.json()['access_token']
        return self.access_token
    
    def create_reading_list(self, title, description, resources):
        if not self.access_token:
            self.authenticate()
            
        headers = {
            'Authorization': f'Bearer {self.access_token}',
            'Content-Type': 'application/vnd.api+json'
        }
        
        # Create reading list
        list_data = {
            "data": {
                "type": "lists",
                "attributes": {
                    "title": title,
                    "description": description,
                    "visibility": "PUBLIC"
                }
            }
        }
        list_url = f"{TALIS_API_URL}{self.tenant}/lists"
        list_response = requests.post(list_url, json=list_data, headers=headers)
        list_response.raise_for_status()
        list_id = list_response.json()['data']['id']
        
        # Add resources
        items_url = f"{TALIS_API_URL}{self.tenant}/lists/{list_id}/items"
        for resource in resources:
            item_data = {
                "data": {
                    "type": "items",
                    "attributes": {
                        "uri": resource.url,
                        "meta": {
                            "title": resource.title,
                            "abstract": resource.description[:500]  # Truncate if needed
                        }
                    }
                }
            }
            item_response = requests.post(items_url, json=item_data, headers=headers)
            item_response.raise_for_status()
        
        return list_id

### Management Commands

---
resources/management/commands/fetch_oer.py
---
from django.core.management.base import BaseCommand
from resources.services.oer_api import fetch_oer_resources
from resources.models import OERResource

class Command(BaseCommand):
    help = 'Fetch OER resources from external APIs'

    def handle(self, *args, **kwargs):
        resources = fetch_oer_resources()
        added = 0
        for data in resources:
            if not OERResource.objects.filter(url=data['url']).exists():
                OERResource.objects.create(
                    title=data['title'],
                    source=data.get('source', 'Unknown'),
                    description=data['description'],
                    license=data.get('license', ''),
                    url=data['url'],
                )
                added += 1
        self.stdout.write(self.style.SUCCESS(f'{added} OER resources fetched and saved.'))

---
resources/management/commands/export_talis.py
---
from django.core.management.base import BaseCommand
from resources.models import Resource
from resources.services.talis_api import create_reading_list

class Command(BaseCommand):
    help = 'Exports selected resources to Talis Reading List'
    
    def add_arguments(self, parser):
        parser.add_argument('--resource-ids', nargs='+', type=int, required=True)
        parser.add_argument('--title', type=str, required=True)
        parser.add_argument('--description', type=str, default='')
    
    def handle(self, *args, **options):
        resources = Resource.objects.filter(id__in=options['resource_ids'])
        list_id = create_reading_list(
            options['title'],
            options['description'],
            resources
        )
        self.stdout.write(self.style.SUCCESS(
            f'Successfully created Talis reading list: {list_id}'
        ))

### Additional Files (Partial Contents)

---
requirements.txt
---
Django==5.2.1
djangorestframework
langchain
langchain-community
langchain-huggingface
chromadb
sentence-transformers==3.0.0
transformers
torch
celery[redis]
redis
pgvector
psycopg2-binary
numpy
pandas
tqdm
django-environ
requests

---
resources/forms.py
---
from django import forms
from .models import OERResource

class BulkCSVUploadForm(forms.Form):
    csv_file = forms.FileField(label="Select CSV file")

class ExportForm(forms.Form):
    title = forms.CharField(max_length=255, required=True)
    description = forms.CharField(widget=forms.Textarea, required=False)
    resource_ids = forms.MultipleChoiceField(
        widget=forms.CheckboxSelectMultiple,
        choices=[]
    )
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['resource_ids'].choices = [
            (r.id, r.title) for r in OERResource.objects.all()
        ]

---
resources/ai_processing.py
---
from langchain_community.vectorstores import Chroma
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from .models import OERResource
from langchain_huggingface import HuggingFaceEmbeddings

class OERRetriever:
    def __init__(self):
        self.embedding = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")
        self.text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
        self.vector_store = None

    def build_vector_store(self):
        resources = OERResource.objects.all()
        documents = []
        metadatas = []
        for resource in resources:
            content = f"Title: {resource.title}\nDescription: {resource.description}"
            metadata = {
                "source": resource.source,
                "license": resource.license,
                "url": resource.url,
                "id": str(resource.id)
            }
            docs = self.text_splitter.split_text(content)
            documents.extend(docs)
            metadatas.extend([metadata] * len(docs))

        if not documents:
            self.vector_store = None
            return

        self.vector_store = Chroma.from_texts(
            texts=documents,
            embedding=self.embedding,
            metadatas=metadatas
        )

    def get_similar_resources(self, query, k=5):
        if not self.vector_store:
            self.build_vector_store()
        if not self.vector_store:
            return []  # No data to search
        results = self.vector_store.similarity_search_with_score(query, k=k)
        output = []
        for doc, score in results:
            output.append((doc, score))  # Return as tuple
        return output

[file content end]